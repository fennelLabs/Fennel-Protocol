<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A WebAssembly linear memory."><meta name="keywords" content="rust, rustlang, rust-lang, Memory"><title>Memory in wasmtime - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../wasmtime/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../wasmtime/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Memory</a></h2><div class="sidebar-elems"><div class="block items"><h3 class="sidebar-title"><a href="#implementations">Associated Constants</a></h3><div class="sidebar-links"><a href="#associatedconstant.ALIGN">ALIGN</a></div><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><div class="sidebar-links"><a href="#method.data_ptr">data_ptr</a><a href="#method.data_size">data_size</a><a href="#method.data_unchecked">data_unchecked</a><a href="#method.data_unchecked_mut">data_unchecked_mut</a><a href="#method.grow">grow</a><a href="#method.new">new</a><a href="#method.read">read</a><a href="#method.size">size</a><a href="#method.ty">ty</a><a href="#method.write">write</a></div><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-From%3CMemory%3E">From&lt;Memory&gt;</a></div><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><div class="sidebar-links"><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">!UnwindSafe</a></div><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-Pointable">Pointable</a><a href="#impl-Same%3CT%3E">Same&lt;T&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a><a href="#impl-VZip%3CV%3E">VZip&lt;V&gt;</a></div></div><h2 class="location">In <a href="index.html">wasmtime</a></h2><div id="sidebar-vars" data-name="Memory" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../wasmtime/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div>
                                <input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Struct <a href="index.html">wasmtime</a>::<wbr><a class="struct" href="#">Memory</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/wasmtime/memory.rs.html#244-247" title="goto source code">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct Memory { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A WebAssembly linear memory.</p>
<p>WebAssembly memories represent a contiguous array of bytes that have a size
that is always a multiple of the WebAssembly page size, currently 64
kilobytes.</p>
<p>WebAssembly memory is used for global data, statics in C/C++/Rust, shadow
stack memory, etc. Accessing wasm memory is generally quite fast!</p>
<h2 id="memory-and-clone" class="section-header"><a href="#memory-and-clone"><code>Memory</code> and <code>Clone</code></a></h2>
<p>Memories are internally reference counted so you can <code>clone</code> a <code>Memory</code>. The
cloning process only performs a shallow clone, so two cloned <code>Memory</code>
instances are equivalent in their functionality.</p>
<h2 id="memory-and-threads" class="section-header"><a href="#memory-and-threads"><code>Memory</code> and threads</a></h2>
<p>It is intended that <code>Memory</code> is safe to share between threads. At this time
this is not implemented in <code>wasmtime</code>, however. This is planned to be
implemented though!</p>
<h2 id="memory-and-safety" class="section-header"><a href="#memory-and-safety"><code>Memory</code> and Safety</a></h2>
<p>Linear memory is a lynchpin of safety for WebAssembly, but it turns out
there are very few ways to safely inspect the contents of a memory from the
host (Rust). This is because memory safety is quite tricky when working with
a <code>Memory</code> and we’re still working out the best idioms to encapsulate
everything safely where it’s efficient and ergonomic. This section of
documentation, however, is intended to help educate a bit what is and isn’t
safe when working with <code>Memory</code>.</p>
<p>For safety purposes you can think of a <code>Memory</code> as a glorified
<code>Rc&lt;UnsafeCell&lt;Vec&lt;u8&gt;&gt;&gt;</code>. There are a few consequences of this
interpretation:</p>
<ul>
<li>
<p>At any time someone else may have access to the memory (hence the <code>Rc</code>).
This could be a wasm instance, other host code, or a set of wasm instances
which all reference a <code>Memory</code>. When in doubt assume someone else has a
handle to your <code>Memory</code>.</p>
</li>
<li>
<p>At any time, memory can be read from or written to (hence the
<code>UnsafeCell</code>). Anyone with a handle to a wasm memory can read/write to it.
Primarily other instances can execute the <code>load</code> and <code>store</code> family of
instructions, as well as any other which modifies or reads memory.</p>
</li>
<li>
<p>At any time memory may grow (hence the <code>Vec&lt;..&gt;</code>). Growth may relocate the
base memory pointer (similar to how <code>vec.push(...)</code> can change the result
of <code>.as_ptr()</code>)</p>
</li>
</ul>
<p>So given that we’re working roughly with <code>Rc&lt;UnsafeCell&lt;Vec&lt;u8&gt;&gt;&gt;</code> that’s a
lot to keep in mind! It’s hopefully though sort of setting the stage as to
what you can safely do with memories.</p>
<p>Let’s run through a few safe examples first of how you can use a <code>Memory</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">wasmtime</span>::{<span class="ident">Memory</span>, <span class="ident">MemoryAccessError</span>};

<span class="comment">// Memory can be read and written safely with the `Memory::read` and</span>
<span class="comment">// `Memory::write` methods.</span>
<span class="comment">// An error is returned if the copy did not succeed.</span>
<span class="kw">fn</span> <span class="ident">safe_examples</span>(<span class="ident">mem</span>: <span class="kw-2">&amp;</span><span class="ident">Memory</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">MemoryAccessError</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">offset</span> <span class="op">=</span> <span class="number">5</span>;
    <span class="ident">mem</span>.<span class="ident">write</span>(<span class="ident">offset</span>, <span class="string">b&quot;hello&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">5</span>];
    <span class="ident">mem</span>.<span class="ident">read</span>(<span class="ident">offset</span>, <span class="kw-2">&amp;mut</span> <span class="ident">buffer</span>)<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(<span class="string">b&quot;hello&quot;</span>, <span class="kw-2">&amp;</span><span class="ident">buffer</span>);
    <span class="prelude-val">Ok</span>(())
}

<span class="comment">// You can also get direct, unsafe access to the memory, but must manually</span>
<span class="comment">// ensure that safety invariants are upheld.</span>

<span class="kw">fn</span> <span class="ident">correct_unsafe_examples</span>(<span class="ident">mem</span>: <span class="kw-2">&amp;</span><span class="ident">Memory</span>) {
    <span class="comment">// Just like wasm, it&#39;s safe to read memory almost at any time. The</span>
    <span class="comment">// gotcha here is that we need to be sure to load from the correct base</span>
    <span class="comment">// pointer and perform the bounds check correctly. So long as this is</span>
    <span class="comment">// all self contained here (e.g. not arbitrary code in the middle) we&#39;re</span>
    <span class="comment">// good to go.</span>
    <span class="kw">let</span> <span class="ident">byte</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="number">0x123</span>] };

    <span class="comment">// Short-lived borrows of memory are safe, but they must be scoped and</span>
    <span class="comment">// not have code which modifies/etc `Memory` while the borrow is active.</span>
    <span class="comment">// For example if you want to read a string from memory it is safe to do</span>
    <span class="comment">// so:</span>
    <span class="kw">let</span> <span class="ident">string_base</span> <span class="op">=</span> <span class="number">0xdead</span>;
    <span class="kw">let</span> <span class="ident">string_len</span> <span class="op">=</span> <span class="number">0xbeef</span>;
    <span class="kw">let</span> <span class="ident">string</span> <span class="op">=</span> <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="ident">string_base</span>..][..<span class="ident">string_len</span>];
        <span class="kw">match</span> <span class="ident">std::str::from_utf8</span>(<span class="ident">bytes</span>) {
            <span class="prelude-val">Ok</span>(<span class="ident">s</span>) =&gt; <span class="ident">s</span>.<span class="ident">to_string</span>(), <span class="comment">// copy out of wasm memory</span>
            <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">panic!</span>(<span class="string">&quot;not valid utf-8&quot;</span>),
        }
    };

    <span class="comment">// Additionally like wasm you can write to memory at any point in time,</span>
    <span class="comment">// again making sure that after you get the unchecked slice you don&#39;t</span>
    <span class="comment">// execute code which could read/write/modify `Memory`:</span>
    <span class="kw">unsafe</span> {
        <span class="ident">mem</span>.<span class="ident">data_unchecked_mut</span>()[<span class="number">0x123</span>] <span class="op">=</span> <span class="number">3</span>;
    }

    <span class="comment">// When working with *borrows* that point directly into wasm memory you</span>
    <span class="comment">// need to be extremely careful. Any functionality that operates on a</span>
    <span class="comment">// borrow into wasm memory needs to be thoroughly audited to effectively</span>
    <span class="comment">// not touch the `Memory` at all</span>
    <span class="kw">let</span> <span class="ident">data_base</span> <span class="op">=</span> <span class="number">0xfeed</span>;
    <span class="kw">let</span> <span class="ident">data_len</span> <span class="op">=</span> <span class="number">0xface</span>;
    <span class="kw">unsafe</span> {
        <span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="ident">data_base</span>..][..<span class="ident">data_len</span>];
        <span class="ident">host_function_that_doesnt_touch_memory</span>(<span class="ident">data</span>);

        <span class="comment">// effectively the same rules apply to mutable borrows</span>
        <span class="kw">let</span> <span class="ident">data_mut</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">mem</span>.<span class="ident">data_unchecked_mut</span>()[<span class="ident">data_base</span>..][..<span class="ident">data_len</span>];
        <span class="ident">host_function_that_doesnt_touch_memory</span>(<span class="ident">data</span>);
    }
}</code></pre></div>
<p>It’s worth also, however, covering some examples of <strong>incorrect</strong>,
<strong>unsafe</strong> usages of <code>Memory</code>. Do not do these things!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">wasmtime::Memory</span>;

<span class="comment">// NOTE: All code in this function is not safe to execute and may cause</span>
<span class="comment">// segfaults/undefined behavior at runtime. Do not copy/paste these examples</span>
<span class="comment">// into production code!</span>
<span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">unsafe_examples</span>(<span class="ident">mem</span>: <span class="kw-2">&amp;</span><span class="ident">Memory</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> {
    <span class="comment">// First and foremost, any borrow can be invalidated at any time via the</span>
    <span class="comment">// `Memory::grow` function. This can relocate memory which causes any</span>
    <span class="comment">// previous pointer to be possibly invalid now.</span>
    <span class="kw">let</span> <span class="ident">pointer</span>: <span class="kw-2">&amp;</span><span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="number">0x100</span>];
    <span class="ident">mem</span>.<span class="ident">grow</span>(<span class="number">1</span>)<span class="question-mark">?</span>; <span class="comment">// invalidates `pointer`!</span>
    <span class="comment">// println!(&quot;{}&quot;, *pointer); // FATAL: use-after-free</span>

    <span class="comment">// Note that the use-after-free also applies to slices, whether they&#39;re</span>
    <span class="comment">// slices of bytes or strings.</span>
    <span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="number">0x100</span>..<span class="number">0x102</span>];
    <span class="ident">mem</span>.<span class="ident">grow</span>(<span class="number">1</span>)<span class="question-mark">?</span>; <span class="comment">// invalidates `slice`!</span>
    <span class="comment">// println!(&quot;{:?}&quot;, slice); // FATAL: use-after-free</span>

    <span class="comment">// Due to the reference-counted nature of `Memory` note that literal</span>
    <span class="comment">// calls to `Memory::grow` are not sufficient to audit for. You&#39;ll need</span>
    <span class="comment">// to be careful that any mutation of `Memory` doesn&#39;t happen while</span>
    <span class="comment">// you&#39;re holding an active borrow.</span>
    <span class="kw">let</span> <span class="ident">slice</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="number">0x100</span>..<span class="number">0x102</span>];
    <span class="ident">some_other_function</span>(); <span class="comment">// may invalidate `slice` through another `mem` reference</span>
    <span class="comment">// println!(&quot;{:?}&quot;, slice); // FATAL: maybe a use-after-free</span>

    <span class="comment">// An especially subtle aspect of accessing a wasm instance&#39;s memory is</span>
    <span class="comment">// that you need to be extremely careful about aliasing. Anyone at any</span>
    <span class="comment">// time can call `data_unchecked()` or `data_unchecked_mut()`, which</span>
    <span class="comment">// means you can easily have aliasing mutable references:</span>
    <span class="kw">let</span> <span class="ident">ref1</span>: <span class="kw-2">&amp;</span><span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">mem</span>.<span class="ident">data_unchecked</span>()[<span class="number">0x100</span>];
    <span class="kw">let</span> <span class="ident">ref2</span>: <span class="kw-2">&amp;mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">mem</span>.<span class="ident">data_unchecked_mut</span>()[<span class="number">0x100</span>];
    <span class="comment">// *ref2 = *ref1; // FATAL: violates Rust&#39;s aliasing rules</span>

    <span class="comment">// Note that aliasing applies to strings as well, for example this is</span>
    <span class="comment">// not valid because the slices overlap.</span>
    <span class="kw">let</span> <span class="ident">slice1</span>: <span class="kw-2">&amp;mut</span> [<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">mem</span>.<span class="ident">data_unchecked_mut</span>()[<span class="number">0x100</span>..][..<span class="number">3</span>];
    <span class="kw">let</span> <span class="ident">slice2</span>: <span class="kw-2">&amp;mut</span> [<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">mem</span>.<span class="ident">data_unchecked_mut</span>()[<span class="number">0x102</span>..][..<span class="number">4</span>];
    <span class="comment">// println!(&quot;{:?} {:?}&quot;, slice1, slice2); // FATAL: aliasing mutable pointers</span>

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Overall there’s some general rules of thumb when working with <code>Memory</code> and
getting raw pointers inside of it:</p>
<ul>
<li>If you never have a “long lived” pointer into memory, you’re likely in the
clear. Care still needs to be taken in threaded scenarios or when/where
data is read, but you’ll be shielded from many classes of issues.</li>
<li>Long-lived pointers must always respect Rust’a aliasing rules. It’s ok for
shared borrows to overlap with each other, but mutable borrows must
overlap with nothing.</li>
<li>Long-lived pointers are only valid if <code>Memory</code> isn’t used in an unsafe way
while the pointer is valid. This includes both aliasing and growth.</li>
</ul>
<p>At this point it’s worth reiterating again that working with <code>Memory</code> is
pretty tricky and that’s not great! Proposals such as <a href="https://github.com/webassembly/interface-types">interface types</a> are
intended to prevent wasm modules from even needing to import/export memory
in the first place, which obviates the need for all of these safety caveats!
Additionally over time we’re still working out the best idioms to expose in
<code>wasmtime</code>, so if you’ve got ideas or questions please feel free to <a href="https://github.com/bytecodealliance/wasmtime/issues/new">open an
issue</a>!</p>
<h3 id="memory-safety-and-threads" class="section-header"><a href="#memory-safety-and-threads"><code>Memory</code> Safety and Threads</a></h3>
<p>Currently the <code>wasmtime</code> crate does not implement the wasm threads proposal,
but it is planned to do so. It’s additionally worthwhile discussing how this
affects memory safety and what was previously just discussed as well.</p>
<p>Once threads are added into the mix, all of the above rules still apply.
There’s an additional, rule, however, that all reads and writes can
happen <em>concurrently</em>. This effectively means that long-lived borrows into
wasm memory are virtually never safe to have.</p>
<p>Mutable pointers are fundamentally unsafe to have in a concurrent scenario
in the face of arbitrary wasm code. Only if you dynamically know for sure
that wasm won’t access a region would it be safe to construct a mutable
pointer. Additionally even shared pointers are largely unsafe because their
underlying contents may change, so unless <code>UnsafeCell</code> in one form or
another is used everywhere there’s no safety.</p>
<p>One important point about concurrency is that <code>Memory::grow</code> can indeed
happen concurrently. This, however, will never relocate the base pointer.
Shared memories must always have a maximum size and they will be
preallocated such that growth will never relocate the base pointer. The
maximum length of the memory, however, will change over time.</p>
<p>Overall the general rule of thumb for shared memories is that you must
atomically read and write everything. Nothing can be borrowed and everything
must be eagerly copied out.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#249-483" title="goto source code">source</a></div><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.new" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#273-279" title="goto source code">source</a></div><a href="#method.new" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.new" class="fnname">new</a>(store: &amp;<a class="struct" href="struct.Store.html" title="struct wasmtime::Store">Store</a>, ty: <a class="struct" href="struct.MemoryType.html" title="struct wasmtime::MemoryType">MemoryType</a>) -&gt; <a class="type" href="../anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a>&gt;</h4></div></summary><div class="docblock"><p>Creates a new WebAssembly memory given the configuration of <code>ty</code>.</p>
<p>The <code>store</code> argument is a general location for cache information, and
otherwise the memory will immediately be allocated according to the
type’s configuration. All WebAssembly memory is initialized to zero.</p>
<h5 id="examples" class="section-header"><a href="#examples">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::default</span>();
<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>);

<span class="kw">let</span> <span class="ident">memory_ty</span> <span class="op">=</span> <span class="ident">MemoryType::new</span>(<span class="ident">Limits::new</span>(<span class="number">1</span>, <span class="prelude-val">None</span>));
<span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">Memory::new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="ident">memory_ty</span>)<span class="question-mark">?</span>;

<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;(module (memory (import \&quot;\&quot; \&quot;\&quot;) 1))&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[<span class="ident">memory</span>.<span class="ident">into</span>()])<span class="question-mark">?</span>;
<span class="comment">// ...</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.ty" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#298-300" title="goto source code">source</a></div><a href="#method.ty" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.ty" class="fnname">ty</a>(&amp;self) -&gt; <a class="struct" href="struct.MemoryType.html" title="struct wasmtime::MemoryType">MemoryType</a></h4></div></summary><div class="docblock"><p>Returns the underlying type of this memory.</p>
<h5 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::default</span>();
<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>);
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;(module (memory (export \&quot;mem\&quot;) 1))&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_memory</span>(<span class="string">&quot;mem&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">ty</span> <span class="op">=</span> <span class="ident">memory</span>.<span class="ident">ty</span>();
<span class="macro">assert_eq!</span>(<span class="ident">ty</span>.<span class="ident">limits</span>().<span class="ident">min</span>(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.read" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#308-318" title="goto source code">source</a></div><a href="#method.read" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.read" class="fnname">read</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;offset: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buffer: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><br>) -&gt; <a class="type" href="../anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.MemoryAccessError.html" title="struct wasmtime::MemoryAccessError">MemoryAccessError</a>&gt;</h4></div></summary><div class="docblock"><p>Safely reads memory contents at the given offset into a buffer.</p>
<p>The entire buffer will be filled.</p>
<p>If offset + buffer length exceed the current memory capacity, then the
buffer is left untouched and a <a href="struct.MemoryAccessError.html" title="MemoryAccessError"><code>MemoryAccessError</code></a> is returned.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.write" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#325-334" title="goto source code">source</a></div><a href="#method.write" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.write" class="fnname">write</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;offset: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;buffer: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><br>) -&gt; <a class="type" href="../anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.MemoryAccessError.html" title="struct wasmtime::MemoryAccessError">MemoryAccessError</a>&gt;</h4></div></summary><div class="docblock"><p>Safely writes contents of a buffer to this memory at the given offset.</p>
<p>If the offset + buffer length exceed current memory capacity, then none
of the buffer is written to memory and a <a href="struct.MemoryAccessError.html" title="MemoryAccessError"><code>MemoryAccessError</code></a> is
returned.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.data_unchecked" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#363-365" title="goto source code">source</a></div><a href="#method.data_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.data_unchecked" class="fnname">data_unchecked</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></div><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Returns this memory as a slice view that can be read natively in Rust.</p>
<h5 id="safety" class="section-header"><a href="#safety">Safety</a></h5>
<p>This is an unsafe operation because there is no guarantee that the
following operations do not happen concurrently while the slice is in
use:</p>
<ul>
<li>Data could be modified by calling into a wasm module.</li>
<li>Memory could be relocated through growth by calling into a wasm
module.</li>
<li>When threads are supported, non-atomic reads will race with other
writes.</li>
</ul>
<p>Extreme care need be taken when the data of a <code>Memory</code> is read. The
above invariants all need to be upheld at a bare minimum, and in
general you’ll need to ensure that while you’re looking at slice you’re
the only one who can possibly look at the slice and read/write it.</p>
<p>Be sure to keep in mind that <code>Memory</code> is reference counted, meaning
that there may be other users of this <code>Memory</code> instance elsewhere in
your program. Additionally <code>Memory</code> can be shared and used in any number
of wasm instances, so calling any wasm code should be considered
dangerous while you’re holding a slice of memory.</p>
<p>For more information and examples see the documentation on the
<a href="struct.Memory.html" title="Memory"><code>Memory</code></a> type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.data_unchecked_mut" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#382-385" title="goto source code">source</a></div><a href="#method.data_unchecked_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.data_unchecked_mut" class="fnname">data_unchecked_mut</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<div class="notable-traits-tooltiptext"><span class="docblock"><div class="notable">Notable traits for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></div><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></span></code></span></div></span></span></h4></div></summary><div class="docblock"><p>Returns this memory as a slice view that can be read and written
natively in Rust.</p>
<h5 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h5>
<p>All of the same safety caveats of <a href="struct.Memory.html#method.data_unchecked" title="Memory::data_unchecked"><code>Memory::data_unchecked</code></a> apply
here, doubly so because this is returning a mutable slice! As a
double-extra reminder, remember that <code>Memory</code> is reference counted, so
you can very easily acquire two mutable slices by simply calling this
function twice. Extreme caution should be used when using this method,
and in general you probably want to result to unsafe accessors and the
<code>data</code> methods below.</p>
<p>For more information and examples see the documentation on the
<a href="struct.Memory.html" title="Memory"><code>Memory</code></a> type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.data_ptr" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#396-398" title="goto source code">source</a></div><a href="#method.data_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.data_ptr" class="fnname">data_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a></h4></div></summary><div class="docblock"><p>Returns the base pointer, in the host’s address space, that the memory
is located at.</p>
<p>When reading and manipulating memory be sure to read up on the caveats
of <a href="struct.Memory.html#method.data_unchecked" title="Memory::data_unchecked"><code>Memory::data_unchecked</code></a> to make sure that you can safely
read/write the memory.</p>
<p>For more information and examples see the documentation on the
<a href="struct.Memory.html" title="Memory"><code>Memory</code></a> type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.data_size" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#406-408" title="goto source code">source</a></div><a href="#method.data_size" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.data_size" class="fnname">data_size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></div></summary><div class="docblock"><p>Returns the byte length of this memory.</p>
<p>The returned value will be a multiple of the wasm page size, 64k.</p>
<p>For more information and examples see the documentation on the
<a href="struct.Memory.html" title="Memory"><code>Memory</code></a> type.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.size" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#411-413" title="goto source code">source</a></div><a href="#method.size" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.size" class="fnname">size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></h4></div></summary><div class="docblock"><p>Returns the size, in pages, of this wasm memory.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.grow" class="method has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#450-457" title="goto source code">source</a></div><a href="#method.grow" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.grow" class="fnname">grow</a>(&amp;self, delta: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="type" href="../anyhow/type.Result.html" title="type anyhow::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;</h4></div></summary><div class="docblock"><p>Grows this WebAssembly memory by <code>delta</code> pages.</p>
<p>This will attempt to add <code>delta</code> more pages of memory on to the end of
this <code>Memory</code> instance. If successful this may relocate the memory and
cause <a href="struct.Memory.html#method.data_ptr" title="Memory::data_ptr"><code>Memory::data_ptr</code></a> to return a new value. Additionally previous
slices into this memory may no longer be valid.</p>
<p>On success returns the number of pages this memory previously had
before the growth succeeded.</p>
<h5 id="errors" class="section-header"><a href="#errors">Errors</a></h5>
<p>Returns an error if memory could not be grown, for example if it exceeds
the maximum limits of this memory.</p>
<h5 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">engine</span> <span class="op">=</span> <span class="ident">Engine::default</span>();
<span class="kw">let</span> <span class="ident">store</span> <span class="op">=</span> <span class="ident">Store::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>);
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::new</span>(<span class="kw-2">&amp;</span><span class="ident">engine</span>, <span class="string">&quot;(module (memory (export \&quot;mem\&quot;) 1 2))&quot;</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">instance</span> <span class="op">=</span> <span class="ident">Instance::new</span>(<span class="kw-2">&amp;</span><span class="ident">store</span>, <span class="kw-2">&amp;</span><span class="ident">module</span>, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">memory</span> <span class="op">=</span> <span class="ident">instance</span>.<span class="ident">get_memory</span>(<span class="string">&quot;mem&quot;</span>).<span class="ident">unwrap</span>();

<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="number">1</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(), <span class="number">2</span>);
<span class="macro">assert!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="number">1</span>).<span class="ident">is_err</span>());
<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">size</span>(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">memory</span>.<span class="ident">grow</span>(<span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">2</span>);</code></pre></div>
</div></details></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Clone" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#243" title="goto source code">source</a></div><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/memory.rs.html#243" title="goto source code">source</a></div><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h4></div></summary><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_from" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#130" title="goto source code">source</a></div><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</h4></div></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3CMemory%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/externals.rs.html#188-192" title="goto source code">source</a></div><a href="#impl-From%3CMemory%3E" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a>&gt; for <a class="enum" href="enum.Extern.html" title="enum wasmtime::Extern">Extern</a></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/wasmtime/externals.rs.html#189-191" title="goto source code">source</a></div><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(r: <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a>) -&gt; Self</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><div id="impl-RefUnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></div><div id="impl-Send" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></div><div id="impl-Sync" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></div><div id="impl-Unpin" class="impl has-srclink"><div class="rightside"></div><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></div><div id="impl-UnwindSafe" class="impl has-srclink"><div class="rightside"></div><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></div></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Any" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132-136" title="goto source code">source</a></div><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.type_id" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#133" title="goto source code">source</a></div><a href="#method.type_id" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></div></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Borrow%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209-214" title="goto source code">source</a></div><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211" title="goto source code">source</a></div><a href="#method.borrow" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</h4></div></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218-222" title="goto source code">source</a></div><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.borrow_mut" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#219" title="goto source code">source</a></div><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</h4></div></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-From%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#549-553" title="goto source code">source</a></div><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.from-1" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#550" title="goto source code">source</a></div><a href="#method.from-1" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Into%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#537-544" title="goto source code">source</a></div><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><div id="method.into" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#541" title="goto source code">source</a></div><a href="#method.into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Pointable" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#194-214" title="goto source code">source</a></div><a href="#impl-Pointable" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a> for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedconstant.ALIGN" class="associatedconstant trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#195" title="goto source code">source</a></div><a href="#associatedconstant.ALIGN" class="anchor"></a><h4 class="code-header">pub const <a href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedconstant.ALIGN" class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></div></summary><div class='docblock'><p>The alignment of pointer.</p>
</div></details><details class="rustdoc-toggle" open><summary><div id="associatedtype.Init" class="type trait-impl has-srclink"><a href="#associatedtype.Init" class="anchor"></a><h4 class="code-header">type <a href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" class="associatedtype">Init</a> = T</h4></div></summary><div class='docblock'><p>The type for initializers.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.init" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#199" title="goto source code">source</a></div><a href="#method.init" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init" class="fnname">init</a>(init: &lt;T as <a class="trait" href="../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a>&gt;::<a class="associatedtype" href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" title="type crossbeam_epoch::atomic::Pointable::Init">Init</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></div></summary><div class='docblock'><p>Initializes a with the given initializer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.deref" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#203" title="goto source code">source</a></div><a href="#method.deref" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref" class="fnname">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T</h4></div></summary><div class='docblock'><p>Dereferences the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.deref_mut" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#207" title="goto source code">source</a></div><a href="#method.deref_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut" class="fnname">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut </a>T</h4></div></summary><div class='docblock'><p>Mutably dereferences the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.drop" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/crossbeam_epoch/atomic.rs.html#211" title="goto source code">source</a></div><a href="#method.drop" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop" class="fnname">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></div></summary><div class='docblock'><p>Drops the object pointed to by the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-Same%3CT%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/typenum/type_operators.rs.html#34-36" title="goto source code">source</a></div><a href="#impl-Same%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a>&lt;T&gt; for T</h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Output" class="type trait-impl has-srclink"><a href="#associatedtype.Output" class="anchor"></a><h4 class="code-header">type <a href="../typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></div></summary><div class='docblock'><p>Should always be <code>Self</code></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-ToOwned" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#84-96" title="goto source code">source</a></div><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Owned" class="type trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></div></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.to_owned" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89" title="goto source code">source</a></div><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></div></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.clone_into" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#93" title="goto source code">source</a></div><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</h4></div></summary><div class="item-info"><div class="stab unstable"><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</div></div><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-TryFrom%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#589-598" title="goto source code">source</a></div><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_from" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#595" title="goto source code">source</a></div><a href="#method.try_from" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-TryInto%3CU%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#574-583" title="goto source code">source</a></div><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><div id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></div></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><div id="method.try_into" class="method trait-impl has-srclink"><div class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#580" title="goto source code">source</a></div><a href="#method.try_into" class="anchor"></a><h4 class="code-header">pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></div></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><div id="impl-VZip%3CV%3E" class="impl has-srclink"><div class="rightside"><a class="srclink" href="../src/ppv_lite86/types.rs.html#221-229" title="goto source code">source</a></div><a href="#impl-VZip%3CV%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;V, T&gt; <a class="trait" href="../ppv_lite86/types/trait.VZip.html" title="trait ppv_lite86::types::VZip">VZip</a>&lt;V&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../ppv_lite86/types/trait.MultiLane.html" title="trait ppv_lite86::types::MultiLane">MultiLane</a>&lt;T&gt;,&nbsp;</span></h3></div></summary><div class="impl-items"><div id="method.vzip" class="method trait-impl has-srclink"><div class="rightside"><a class="srclink" href="../src/ppv_lite86/types.rs.html#226" title="goto source code">source</a></div><a href="#method.vzip" class="anchor"></a><h4 class="code-header">pub fn <a href="../ppv_lite86/types/trait.VZip.html#tymethod.vzip" class="fnname">vzip</a>(self) -&gt; V</h4></div></div></details></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="wasmtime" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0-nightly (17d29dcdc 2022-01-21)" ></div>
</body></html>